ETL CANON V1 — вопросы и ответы (зафиксировано)
Цель
Этот документ фиксирует ответы на типовые вопросы, чтобы их не задавали повторно и не пытались “улучшать” канон. Канон фиксирует инварианты. Политики эксплуатации, пороги алертов, SRE-процедуры и коммерческие решения живут выше канона.
Общие вопросы по архитектуре и проектированию
1) Границы модулей: что если в файле 99% BAD-строк?
Ответ: канон сознательно не задаёт процент. BAD-строки не валят файл. Gate фиксирует PASS/WARN/FAIL по событию файла. Наличие BAD даёт минимум WARN. Алертинг и решение “что делать” лежат выше (оркестратор/процессы). FAIL — только ошибки уровня файла (нечитаемость/сломанная структура/нарушение контракта файла).
2) SSOT и история: журнал растёт бесконечно. Что с архивом и “правом на забвение”?
Ответ: рост SSOT нормален. Архивация — политика хранения (горячее/холодное/архив) и решается на уровне хранилища. “Право на забвение” решается на уровне доступа и витрины (исключение/маскирование), а не переписыванием истории.
3) Идемпотентность: один и тот же файл обработали дважды разными run_id.
Ответ: канон даёт механизмы (run_id, effective_at, метрики, артефакты). Защита от повторной обработки — обязанность оркестратора/операционного контура. История допустит два события, а витрина выбирает “что считать актуальным” своими правилами.
4) Обратная совместимость: как жить с ndjson_contract_version?
Ответ: переход делается через параллельную поддержку в потребителях Curated/Offers на согласованный период. NDJSON — контракт, изменения требуют версии.
5) Масштабирование: что масштабируется, а что нет?
Ответ: Extractor/Emitter потоковые и масштабируются горизонтально легко. Ingestion stateful (история, блокировки) и масштабируется осторожно. Это нормальная структура.
Вопросы по данным и парсингу (Extractor/Emitter)
1) Кто контролирует согласованный формат поставщика, если формат “плавает”?
Ответ: это решается mapping’ами и parser_id. Формат “поплыл” — новый parser_id и/или новый mapping_version. Система не должна угадывать молча.
2) Unicode NFKC нормализация SKU: а если стало пусто или коллизии?
Ответ: пустой SKU после нормализации — BAD. Коллизии возможны и допустимы как факт. Бизнес-уникальность не решается на этом уровне.
3) Добавление XLSX/CSV/API: когда и как?
Ответ: добавление нового формата = новый parser_id (и при необходимости новая ветка extract). Контракт GOOD-строк NDJSON остаётся, меняется реализация чтения и идентификатор.
4) “Новый тип BAD”: как формализовать?
Ответ: BAD имеет причину из фиксированного реестра (список кодов). Новый код — изменение системы и требует фиксации версией и review. Владелец — команда ETL.
5) Память/производительность: что с огромными файлами (например 1ГБ)?
Ответ: канон подразумевает hardening-лимиты и отказ до обработки. Система защищает себя. Огромные файлы не являются нормой для v1.
6) Контекст ошибки для BAD-строк: нужно ли сохранять больше?
Ответ: минимально сохраняется сама строка (raw фрагмент), номер и причина. Допконтекст (заголовки/соседние ячейки) допустим как расширение артефакта, но не обязателен.
7) mapping.yaml: насколько он “умный”?
Ответ: mapping не является языком программирования и не должен содержать бизнес-логику, if-else и справочники, меняющие смысл данных. Он описывает расположение и прямые преобразования.
Вопросы по Gate и бизнес-логике
1) Что такое “нарушение контракта файла” для FAIL?
Ответ: отсутствие обязательных колонок/листов/структуры, невозможность корректно определить таблицу, несоответствие header_probe/обязательным структурным ожиданиям, невалидный выходной контракт события.
2) BAD-строк очень много: почему не FAIL?
Ответ: потому что канон разводит “факт плохих строк” и “катастрофу файла”. Плохие строки уходят в BAD, GOOD продолжают идти. Сигнал — WARN и алерты по новизне/деградации выше канона.
3) Force-ingest: последствия и процедуры?
Ответ: force_ingest — осознанное решение человека “принять риск”. Требует обязательного force_reason и аудит-следа. Конкретные роли и процедуры — организационный уровень.
4) Где живут правила Curated/Offers и как меняются?
Ответ: это отдельный слой со своим версионированием, тестированием и регламентом изменений. Канон запрещает перенос бизнес-правил вниз.
5) Изменение mapping: влияет ли на историю?
Ответ: история не переписывается. Витрина может пересчитываться по новым правилам чтения будущих событий. Перепарс исторического — отдельная управляемая операция, если она вообще нужна.
Вопросы по эксплуатации и DevOps
1) Мониторинг “деградации”: что это?
Ответ: рост BAD, появление новых причин BAD, изменения структуры, рост времени обработки, рост объёма, исчезновение прогонов. Конкретные пороги алертов — политика эксплуатации.
2) Distributed lock на run_id: как реализовать и что с зависанием?
Ответ: любая надёжная реализация (БД/Redis/и т.п.). Должны быть таймауты, обновление lease и аварийное снятие по процедуре. Детали — эксплуатационный уровень.
3) Rate limiting по supplier_id: что происходит при превышении?
Ответ: очередь или отказ — выбор оркестратора. Канон фиксирует необходимость защиты, не диктует механику.
4) Восстановление после сбоя Ingestion:
Ответ: повтор по run_id с очисткой незасиленного промежуточного состояния. Append-only история и идемпотентные артефакты облегчают восстановление.
5) Кто контролирует parser_id и ndjson_contract_version?
Ответ: это архитектурные изменения и должны проходить review. CI может проверять правила, но решение остаётся управленческим.
6) Где хранить логи и артефакты BAD, и как долго?
Ответ: хранить достаточно долго для аудита и разбора инцидентов. Доступ и сроки — политика эксплуатации. Канон требует наличие следа.
7) Зависимости и уязвимости (xlrd 1.2.0):
Ответ: фиксация версии — осознанный компромисс v1. Мониторинг уязвимостей и план обновления — отдельный процесс, смена библиотеки = новый parser_id.
8) Деплой новой версии Emitter с новым parser_id:
Ответ: новые parser_id добавляются параллельно старым. Старые продолжают работать для своих поставщиков. Это нормальная эксплуатационная модель.
Вопросы по взаимодействию и поддержке
1) Коммуникация с поставщиками:
Ответ: на основе агрегированной статистики причин BAD и примеров, а не “потому что система сказала”. Это помогает договориться о формате.
2) “Почему в витрине нет товара X?”
Ответ: потому что он не стал валидным фактом (ушёл в BAD) или витрина его отфильтровала по бизнес-правилам. Детали BAD — внутренняя диагностика.
3) Документация по parser_id:
Ответ: должна жить рядом с mapping/кодом и версионироваться вместе с ними. Иначе неизбежно рассинхронизируется.
4) Регресс-тесты парсеров:
Ответ: нужны эталонные (golden) входы и ожидаемые выходы для ключевых parser_id. Без этого система деградирует незаметно.
5) Стоимость хранения SSOT и BAD:
Ответ: SSOT дорог, но дешевле потери доверия. Архивация и сроки хранения — политика, решаемая отдельно.
