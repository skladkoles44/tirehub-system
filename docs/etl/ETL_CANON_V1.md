ETL CANON V1 (SSOT / Marketplace-ready)
Назначение
Контур предназначен для приёма прайс-листов поставщиков, фиксации фактов «что поставщик прислал» без бизнес-эвристик и построения витрины только поверх проверенных и валидных данных. SSOT является журналом фактов, а не «актуальным состоянием».
1. Общие принципы
Система построена по модели: Extractor → Emitter → Gate → Ingestion → Curated / Offers.
NDJSON-first. Каждая строка-факт атомарна и независима.
Extractor извлекает строки из входного файла и ничего не решает.
Emitter решает судьбу каждой строки.
Gate решает судьбу файла как события.
Ingestion фиксирует историю навсегда.
Curated / Offers — единственное место бизнес-логики.
2. Термины
parser_id — идентификатор логики парсинга: поставщик + формат/лейаут + реализация emitter. Любой breaking change алгоритма или контракта = новый parser_id.
mapping_schema_version — версия схемы mapping.yaml (ключ version в YAML).
mapping_version — версия конкретного mapping-файла как артефакта. Меняется при любом изменении содержимого.
ndjson_contract_version — версия структуры NDJSON. Breaking change требует нового ndjson_contract_version и нового parser_id.
effective_at — момент актуальности данных, задаётся оркестратором.
run_id — идентификатор одного прогона (один входной файл).
SSOT — append-only журнал фактов.
3. Extractor
Extractor открывает входной файл, находит таблицы и читает строки.
Extractor передаёт строки дальше построчно, по мере чтения.
Extractor не принимает решений, не фильтрует и не хранит данные.
Extractor может держать временные данные в памяти только по необходимости формата (листы, заголовки, смещения), но не является хранилищем.
4. Emitter
Вход: строки от Extractor + mapping.yaml.
Поддержка v1: только XLS через xlrd 1.2.0.
Если файл не читается или структура нарушена — CRITICAL лог + exit code ≠ 0.
Emitter обрабатывает файл построчно.
Для каждой строки Emitter принимает решение GOOD или BAD.
GOOD-строка
Строка валидна и соответствует контракту.
GOOD-строка превращается в факт NDJSON.
GOOD-строки формируют основной NDJSON-поток.
BAD-строка
Строка невалидна, неразбираема или запрещена правилом.
BAD-строка не превращается в факт и не попадает в NDJSON.
Для каждой BAD-строки фиксируется причина.
BAD-строки формируют отдельный артефакт (например bad_rows.ndjson).
Emitter не делает дедупликацию и не применяет бизнес-правила.
Emitter нормализует SKU: Unicode NFKC, удаление zero-width, trim, collapse whitespace.
Полностью пустые строки пропускаются и учитываются в метриках.
Emitter формирует stats-out с количеством GOOD и BAD строк и типами причин.
5. NDJSON контракт (только GOOD)
Каждая строка-факт содержит: supplier_id, parser_id, mapping_version, ndjson_contract_version, emitter_version, run_id, effective_at, sku_candidate_key, raw, parsed, quality_flags, _meta.
effective_at — строго RFC3339 UTC с Z.
Валюта не передаётся: всегда RUB.
parsed.price — целое число в копейках или null (ROUND_HALF_UP).
parsed.qty — целое число или null.
raw сохраняет исходные значения.
_meta.source_row_number — 1-based.
6. Флаги качества (GOOD-строки)
Флаги не каскадируются, порядок проверки фиксирован.
price_textual, negative_price, zero_price, missing_price.
qty_textual, qty_fractional, negative_qty, missing_qty.
Диапазоны: price 100..10_000_000 коп., qty 0..100_000.
Выход за диапазон = WARN.
negative_price — WARN всегда.
7. BAD-строки (row-level parse errors)
BAD-строка — строка, для которой невозможно сформировать валидный факт NDJSON.
BAD-строки не являются фактами и не участвуют в витрине.
BAD-строки хранятся отдельно с исходными данными строки, номером строки источника и причиной.
Emitter не падает из-за отдельных BAD-строк, если файл читается и структура сохранена.
Известные BAD-паттерны обрабатываются тихо и регистрируются в журнале.
Новый тип BAD или изменение характера BAD — повод для алерта.
8. Gate
Gate не работает со строками.
Gate работает с файлом как событием.
Gate получает итог от Emitter: количество GOOD, количество BAD, типы причин, статус чтения файла.
Gate принимает одно решение по файлу: PASS, WARN или FAIL.
PASS — файл принят без шума.
WARN — файл принят, но есть BAD-строки или некритичные сигналы.
FAIL — файл как событие не состоялся (нечитаемый файл, сломанная структура, нарушение контракта).
Наличие BAD-строк не является FAIL.
FAIL возможен только по ошибкам уровня файла.
9. Ingestion
Ingestion работает только если Gate вернул PASS или WARN.
Ingestion принимает только GOOD-факты.
SSOT — append-only, дубликаты допустимы.
BAD-строки в SSOT не попадают.
run_id уникален. Параллельный ingestion одного run_id запрещён.
10. Curated / Offers
Работает поверх SSOT.
Использует только GOOD-факты.
Условие оффера: parsed.price > 0 и parsed.qty > 0, нет FAIL-флагов.
BAD-строки и причины их появления витрине неизвестны.
Вся бизнес-логика реализуется только здесь.
11. Версионирование
Новый parser_id обязателен при изменении алгоритмов, библиотеки чтения, ndjson_contract_version или обязательных полей NDJSON.
Новый mapping_version — при любом изменении mapping.
CI блокирует merge, если mapping изменён без увеличения версии.
12. Force-ingest
force_ingest и force_reason фиксируются в метаданных.
Доступ только для администраторов.
Все случаи логируются и алертятся.
13. Мониторинг
Отсчёт отсутствия прогонов ведётся от последнего PASS или WARN.
Алерты строятся по новизне и деградации, а не по единичным BAD-строкам.
14. Hardening v1
Лимиты на размер файла, строки, колонки, склады.
Unicode-нормализация SKU обязательна.
Distributed lock на run_id.
Rate limiting по supplier_id.
15. Граница ответственности
Extractor извлекает.
Emitter решает судьбу строк.
Gate решает судьбу файла.
Ingestion хранит историю.
Curated реализует бизнес.
Это канон v1.
Он фиксирует реальность, не скрывает проблемы и позволяет системе работать тихо и устойчиво в фоне.
